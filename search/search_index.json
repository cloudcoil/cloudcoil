{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"cloudcoil","text":"<p>\ud83d\ude80 Cloud native operations made beautifully simple with Python</p> <p> </p> <p>Modern, async-first Kubernetes client with elegant Pythonic syntax and full type safety</p>"},{"location":"#support-the-project","title":"\ud83e\udd1d Support the Project","text":"<p>If you find Cloudcoil useful, please consider giving it a star on GitHub! Your support helps the project grow and encourages continued development.</p> <p></p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udd25 Elegant, Pythonic API - Feels natural to Python developers including fluent and context manager style resource builders</li> <li>\u26a1 Async First - Native async/await support for high performance</li> <li>\ud83d\udee1\ufe0f Type Safe - Full mypy support and runtime validation</li> <li>\ud83e\uddea Testing Ready - Built-in pytest fixtures for K8s integration tests</li> <li>\ud83d\udce6 Zero Config - Works with your existing kubeconfig</li> <li>\ud83e\udeb6 Minimal Dependencies - Only requires httpx, pydantic, and pyyaml</li> </ul>"},{"location":"#installation","title":"\ud83d\udd27 Installation","text":"<p>[!NOTE] For versioning information and compatibility, see the Versioning Guide.</p> <p>Using uv (recommended):</p> <pre><code># Install with Kubernetes support\nuv add cloudcoil[kubernetes]\n\n# Install with specific Kubernetes version compatibility\nuv add cloudcoil[kubernetes-1-29]\nuv add cloudcoil[kubernetes-1-30]\nuv add cloudcoil[kubernetes-1-31]\nuv add cloudcoil[kubernetes-1-32]\n</code></pre> <p>Using pip:</p> <pre><code>pip install cloudcoil[kubernetes]\n</code></pre>"},{"location":"#integrations","title":"\ud83d\udd0c Integrations","text":"<p>Discover more Cloudcoil model integrations for popular Kubernetes operators and CRDs at cloudcoil-models on GitHub.</p> <p>Current first-class integrations include:</p> Name Github PyPI cert-manager models-cert-manager cloudcoil.models.cert_manager fluxcd models-fluxcd cloudcoil.models.fluxcd istio models-istio cloudcoil.models.istio keda models-keda cloudcoil.models.keda knative-serving models-knative-serving cloudcoil.models.knative_serving knative-eventing models-knative-eventing cloudcoil.models.knative_eventing kpack models-kpack cloudcoil.models.kpack kyverno models-kyverno cloudcoil.models.kyverno prometheus-operator models-prometheus-operator cloudcoil.models.prometheus_operator sealed-secrets models-sealed-secrets cloudcoil.models.sealed_secrets velero models-velero cloudcoil.models.velero <p>You can install these integrations using</p> <pre><code>uv add cloudcoil[kyverno]\n# You can also install multiple dependencies at once\nuv add cloudcoil[cert-manager,fluxcd,kyverno]\n# You can also install all available models in cloudcoil using\nuv add cloudcoil[all-models]\n</code></pre> <p>Missing an integration you need? Open a model request to suggest a new integration!</p>"},{"location":"#examples","title":"\ud83d\udca1 Examples","text":""},{"location":"#reading-resources","title":"Reading Resources","text":"<pre><code>from cloudcoil.client import Config\nimport cloudcoil.models.kubernetes as k8s\n\n# Get a resource - as simple as that!\nservice = k8s.core.v1.Service.get(\"kubernetes\")\n\n# List resources with elegant pagination\nfor pod in k8s.core.v1.Pod.list(namespace=\"default\"):\n    print(f\"Found pod: {pod.metadata.name}\")\n\n# Async support out of the box\nasync for pod in await k8s.core.v1.Pod.async_list():\n    print(f\"Found pod: {pod.metadata.name}\")\n</code></pre>"},{"location":"#building-resources","title":"Building resources","text":""},{"location":"#using-models","title":"Using Models","text":"<pre><code>from cloudcoil import apimachinery\nimport cloudcoil.models.kubernetes.core.v1 as k8score\nimport cloudcoil.models.kubernetes.apps.v1 as k8sapps\n\n# Create a Deployment\ndeployment = k8sapps.Deployment(\n    metadata=apimachinery.ObjectMeta(name=\"nginx\"),\n    spec=k8sapps.DeploymentSpec(\n        replicas=3,\n        selector=apimachinery.LabelSelector(\n            match_labels={\"app\": \"nginx\"}\n        ),\n        template=k8score.PodTemplateSpec(\n            metadata=apimachinery.ObjectMeta(\n                labels={\"app\": \"nginx\"}\n            ),\n            spec=k8score.PodSpec(\n                containers=[\n                    k8score.Container(\n                        name=\"nginx\",\n                        image=\"nginx:latest\",\n                        ports=[k8score.ContainerPort(container_port=80)]\n                    )\n                ]\n            )\n        )\n    )\n).create()\n\n# Create a Service\nservice = k8score.Service(\n    metadata=apimachinery.ObjectMeta(name=\"nginx\"),\n    spec=k8score.ServiceSpec(\n        selector={\"app\": \"nginx\"},\n        ports=[k8score.ServicePort(port=80, target_port=80)]\n    )\n).create()\n\n# List Deployments\nfor deploy in k8sapps.Deployment.list():\n    print(f\"Found deployment: {deploy.metadata.name}\")\n\n# Update a Deployment\ndeployment.spec.replicas = 5\ndeployment.save()\n\n# Delete resources\nk8score.Service.delete(\"nginx\")\nk8sapps.Deployment.delete(\"nginx\")\n</code></pre>"},{"location":"#using-the-fluent-builder-api","title":"Using the Fluent Builder API","text":"<p>Cloudcoil provides a powerful fluent builder API for Kubernetes resources with full IDE support and rich autocomplete capabilities:</p> <pre><code>from cloudcoil.models.kubernetes.apps.v1 import Deployment\nfrom cloudcoil.models.kubernetes.core.v1 import Service\n\n# Create a Deployment using the fluent builder\n# The fluent style is great for one-liners and simple configurations\nnginx_deployment = (\n    Deployment.builder()\n    # Metadata can be configured in a single chain for simple objects\n    .metadata(lambda metadata: metadata\n        .name(\"nginx\")\n        .namespace(\"default\")\n    )\n    # Complex nested structures can be built using nested lambda functions\n    .spec(lambda deployment_spec: deployment_spec\n        .replicas(3)\n        # Each level of nesting gets its own lambda for clarity\n        .selector(lambda label_selector: label_selector\n            .match_labels({\"app\": \"nginx\"})\n        )\n        .template(lambda pod_template: pod_template\n            .metadata(lambda pod_metadata: pod_metadata\n                .labels({\"app\": \"nginx\"})\n            )\n            .spec(lambda pod_spec: pod_spec\n                # Lists can be built using array literals with lambda items\n                .containers([\n                    lambda container: container\n                    .name(\"nginx\")\n                    .image(\"nginx:latest\")\n                    # Nested collections can use the add() helper\n                    .ports(lambda port_list: port_list.add(\n                        lambda port: port.container_port(80)\n                    ))\n                ])\n            )\n        )\n    )\n    .build()\n)\n\n# Create a Service using the builder\nservice = (\n    Service.builder()\n    .metadata(lambda m: m\n        .name(\"nginx\")\n        .namespace(\"default\")\n    )\n    .spec(lambda s: s\n        .selector({\"app\": \"nginx\"})\n        .ports(lambda ports: ports.add(lambda p: p.container_port(80)))\n    )\n    .build()\n)\n</code></pre> <p>The fluent builder provides: - \u2728 Full IDE support with detailed type information - \ud83d\udd0d Rich autocomplete for all fields and nested objects - \u26a1 Compile-time validation of your configuration - \ud83c\udfaf Clear and chainable API that guides you through resource creation</p>"},{"location":"#using-the-context-manager-builder-api","title":"Using the Context Manager Builder API","text":"<p>For complex nested resources, Cloudcoil also provides a context manager-based builder pattern that can make the structure more clear:</p> <pre><code>from cloudcoil.models.kubernetes.apps.v1 import Deployment\nfrom cloudcoil.models.kubernetes.core.v1 import Service\n\n# Create a deployment using context managers\n# Context managers are ideal for deeply nested structures\nwith Deployment.new() as nginx_deployment:\n    # Each context creates a clear visual scope\n    with nginx_deployment.metadata() as deployment_metadata:\n        deployment_metadata.name(\"nginx\")\n        deployment_metadata.namespace(\"default\")\n\n    with nginx_deployment.spec() as deployment_spec:\n        # Simple fields can be set directly\n        deployment_spec.replicas(3)\n\n        # Each nested object gets its own context\n        with deployment_spec.selector() as label_selector:\n            label_selector.match_labels({\"app\": \"nginx\"})\n\n        with deployment_spec.template() as pod_template:\n            with pod_template.metadata() as pod_metadata:\n                pod_metadata.labels({\"app\": \"nginx\"})\n\n            with pod_template.spec() as pod_spec:\n                # Collections use a parent context for the list\n                with pod_spec.containers() as container_list:\n                    # And child contexts for each item\n                    with container_list.add() as nginx_container:\n                        nginx_container.name(\"nginx\")\n                        nginx_container.image(\"nginx:latest\")\n                        # Ports can be added one by one\n                        with nginx_container.add_port() as container_port:\n                            container_port.container_port(80)\n\nfinal_deployment = nginx_deployment.build()\n\n# Create a service using context managers\nwith Service.new() as nginx_service:\n    # Context managers make the structure very clear\n    with nginx_service.metadata() as service_metadata:\n        service_metadata.name(\"nginx\")\n        service_metadata.namespace(\"default\")\n\n    with nginx_service.spec() as service_spec:\n        # Simple fields can still be set directly\n        service_spec.selector({\"app\": \"nginx\"})\n        # Port configuration is more readable with contexts\n        with service_spec.add_port() as service_port:\n            service_port.port(80)\n            service_port.target_port(80)\n\nfinal_service = nginx_service.build()\n</code></pre> <p>The context manager builder provides: - \ud83c\udfad Clear visual nesting of resource structure - \ud83d\udd12 Automatic resource cleanup - \ud83c\udfaf Familiar Python context manager pattern - \u2728 Same great IDE support as the fluent builder</p>"},{"location":"#mixing-builder-styles","title":"Mixing Builder Styles","text":"<p>CloudCoil's intelligent builder system automatically detects which style you're using and provides appropriate IDE support:</p> <pre><code>from cloudcoil.models.kubernetes.apps.v1 import Deployment\nfrom cloudcoil import apimachinery\n\n# Mixing styles lets you choose the best approach for each part\n# The IDE automatically adapts to your chosen style at each level\nwith Deployment.new() as nginx_deployment:\n    # Direct object initialization with full type checking\n    nginx_deployment.metadata(apimachinery.ObjectMeta(\n        name=\"nginx\",\n        namespace=\"default\",\n        labels={\"app\": \"nginx\"}\n    ))\n\n    with nginx_deployment.spec() as deployment_spec:\n        # IDE shows all available fields with types\n        deployment_spec.replicas(3)\n        # Fluent style with rich autocomplete\n        deployment_spec.selector(lambda sel: sel.match_labels({\"app\": \"nginx\"}))\n\n        # Context manager style with full type hints\n        with deployment_spec.template() as pod_template:\n            # Mix and match freely - IDE adjusts automatically\n            pod_template.metadata(apimachinery.ObjectMeta(labels={\"app\": \"nginx\"}))\n            with pod_template.spec() as pod_spec:\n                with pod_spec.containers() as container_list:\n                    with container_list.add() as nginx_container:\n                        # Complete IDE support regardless of style\n                        nginx_container.name(\"nginx\")\n                        nginx_container.image(\"nginx:latest\")\n                        # Switch styles any time\n                        nginx_container.ports(lambda ports: ports\n                            .add(lambda p: p.container_port(80))\n                            .add(lambda p: p.container_port(443))\n                        )\n\nfinal_deployment = nginx_deployment.build()\n</code></pre> <p>This flexibility allows you to: - \ud83d\udd00 Choose the most appropriate style for each part of your configuration - \ud83d\udcd6 Maximize readability for both simple and complex structures - \ud83c\udfa8 Format your code according to your team's preferences - \ud83e\udde0 Get full IDE support with automatic style detection - \u2728 Enjoy rich autocomplete in all styles - \u26a1 Benefit from type checking across mixed styles - \ud83c\udfaf Receive immediate feedback on type errors - \ud83d\udd0d See documentation for all fields regardless of style</p>"},{"location":"#creating-resources","title":"Creating Resources","text":"<pre><code># Create with Pythonic syntax\nnamespace = k8s.core.v1.Namespace(\n    metadata=dict(name=\"dev\")\n).create()\n\n# Generate names automatically\ntest_ns = k8s.core.v1.Namespace(\n    metadata=dict(generate_name=\"test-\")\n).create()\n</code></pre>"},{"location":"#modifying-resources","title":"Modifying Resources","text":"<pre><code># Update resources fluently\ndeployment = k8s.apps.v1.Deployment.get(\"web\")\ndeployment.spec.replicas = 3\ndeployment.update()\n\n# Or use the save method which handles both create and update\nconfigmap = k8s.core.v1.ConfigMap(\n    metadata=dict(name=\"config\"),\n    data={\"key\": \"value\"}\n)\nconfigmap.save()  # Creates the ConfigMap\n\nconfigmap.data[\"key\"] = \"new-value\"\nconfigmap.save()  # Updates the ConfigMap\n</code></pre>"},{"location":"#deleting-resources","title":"Deleting Resources","text":"<pre><code># Delete by name\nk8s.core.v1.Pod.delete(\"nginx\", namespace=\"default\")\n\n# Or remove the resource instance\npod = k8s.core.v1.Pod.get(\"nginx\")\npod.remove()\n</code></pre>"},{"location":"#watching-resources","title":"Watching Resources","text":"<pre><code>for event_type, resource in k8s.core.v1.Pod.watch(field_selector=\"metadata.name=mypod\"):\n    # Wait for the pod to be deleted\n    if event_type == \"DELETED\":\n        break\n\n# You can also use the async watch\nasync for event_type, resource in await k8s.core.v1.Pod.async_watch(field_selector=\"metadata.name=mypod\"):\n    # Wait for the pod to be deleted\n    if event_type == \"DELETED\":\n        break\n</code></pre>"},{"location":"#waiting-for-resources","title":"Waiting for Resources","text":"<pre><code># Wait for a resource to reach a desired state\npod = k8s.core.v1.Pod.get(\"nginx\")\npod.wait_for(lambda _, pod: pod.status.phase == \"Running\", timeout=300)\n\n# You can also check of the resource to be deleted\nawait pod.async_wait_for(lambda event, _: event == \"DELETED\", timeout=300)\n\n# You can also supply multiple conditions. The wait will end when the first condition is met.\n# It will also return the key of the condition that was met.\ntest_pod = k8s.core.v1.Pod.get(\"tests\")\nstatus = await test_pod.async_wait_for({\n    \"succeeded\": lambda _, pod: pod.status.phase == \"Succeeded\",\n    \"failed\": lambda _, pod: pod.status.phase == \"Failed\"\n    }, timeout=300)\nassert status == \"succeeded\"\n</code></pre>"},{"location":"#dynamic-resources","title":"Dynamic Resources","text":"<pre><code>from cloudcoil.resources import get_dynamic_resource\n\n# Get a dynamic resource class for any CRD or resource without a model\nDynamicJob = get_dynamic_resource(\"Job\", \"batch/v1\")\n\n# Create using dictionary syntax\njob = DynamicJob(\n    metadata={\"name\": \"dynamic-job\"},\n    spec={\n        \"template\": {\n            \"spec\": {\n                \"containers\": [{\"name\": \"job\", \"image\": \"busybox\"}],\n                \"restartPolicy\": \"Never\"\n            }\n        }\n    }\n)\n\n# Create on the cluster\ncreated = job.create()\n\n# Access fields using dict-like syntax\nassert created[\"spec\"][\"template\"][\"spec\"][\"containers\"][0][\"image\"] == \"busybox\"\n\n# Update fields\ncreated[\"spec\"][\"template\"][\"spec\"][\"containers\"][0][\"image\"] = \"alpine\"\nupdated = created.update()\n\n# Get raw dictionary representation\nraw_dict = updated.raw\n</code></pre>"},{"location":"#resource-parsing","title":"Resource Parsing","text":"<pre><code>from cloudcoil import resources\n\n# Parse YAML files\ndeployment = resources.parse_file(\"deployment.yaml\")\n\n# Parse multiple resources\nresources = resources.parse_file(\"k8s-manifests.yaml\", load_all=True)\n\n# Get resource class by GVK if its an existing resource model class\nJob = resources.get_model(\"Job\", api_version=\"batch/v1\")\n</code></pre>"},{"location":"#context-management","title":"Context Management","text":"<pre><code># Temporarily switch namespace\nwith Config(namespace=\"kube-system\"):\n    pods = k8s.core.v1.Pod.list()\n\n# Custom configs\nwith Config(kubeconfig=\"dev-cluster.yaml\"):\n    services = k8s.core.v1.Service.list()\n</code></pre>"},{"location":"#high-performance-with-caching","title":"\u26a1 High Performance with Caching","text":"<p>Cloudcoil provides powerful client-side caching and real-time resource synchronization, delivering 100-200x performance improvements on read operations:</p> <pre><code>from cloudcoil.client import Config\nfrom cloudcoil.caching import Cache\nimport cloudcoil.models.kubernetes as k8s\n\n# Simple caching - just add cache=True!\nconfig = Config(cache=True)\n\nwith config:\n    # First call hits API and populates cache (~50ms)\n    deployment = k8s.apps.v1.Deployment.get(\"my-app\")\n\n    # Subsequent calls served from cache (&lt;1ms)\n    deployment = k8s.apps.v1.Deployment.get(\"my-app\")\n\n    # Lists are also cached\n    pods = k8s.core.v1.Pod.list()  # &lt;5ms from cache\n\n    # Writes go through API, cache updates automatically\n    deployment.spec.replicas = 5\n    deployment.update()  # Updates API and cache\n</code></pre>"},{"location":"#event-handlers-with-informers","title":"Event Handlers with Informers","text":"<pre><code>from cloudcoil.client import Config\nfrom cloudcoil.caching import Cache\nimport cloudcoil.models.kubernetes as k8s\n\n# Enable caching with custom settings\nconfig = Config(\n    cache=Cache(resync_period=600)  # Resync every 10 minutes\n)\n\nwith config:\n    # Get informer for Deployments through the cache\n    deployment_informer = config.cache.get_informer(k8s.apps.v1.Deployment)\n\n    # Register event handlers\n    @deployment_informer.on_add\n    def handle_new_deployment(deployment):\n        print(f\"New deployment: {deployment.metadata.name}\")\n\n    @deployment_informer.on_update\n    def handle_update(old_deployment, new_deployment):\n        if old_deployment.spec.replicas != new_deployment.spec.replicas:\n            print(f\"Deployment {new_deployment.metadata.name} scaled\")\n\n    @deployment_informer.on_delete\n    def handle_delete(deployment):\n        print(f\"Deployment deleted: {deployment.metadata.name}\")\n\n    # Access the local cache store\n    store = deployment_informer.get_store()\n    all_deployments = store.list()  # Instant, no API call\n    specific = store.get(\"my-app\")  # Instant lookup\n\n    # The informer lifecycle is managed by Config context\n</code></pre>"},{"location":"#async-event-handlers","title":"Async Event Handlers","text":"<pre><code>from cloudcoil.client import Config\nfrom cloudcoil.caching import Cache\nimport cloudcoil.models.kubernetes as k8s\n\n# Async context for high-performance applications\nconfig = Config(cache=True)\n\nasync def monitor_pods():\n    async with config:\n        # Get async informer for Pods\n        pod_informer = config.cache.get_informer(\n            k8s.core.v1.Pod,\n            sync=False  # Get async informer\n        )\n\n        # Async event handlers\n        @pod_informer.on_add\n        async def handle_new_pod(pod):\n            print(f\"New pod: {pod.metadata.name}\")\n            # Can perform async operations here\n            await notify_external_system(pod)\n\n        @pod_informer.on_update\n        async def handle_pod_update(old_pod, new_pod):\n            if old_pod.status.phase != new_pod.status.phase:\n                print(f\"Pod {new_pod.metadata.name} phase changed\")\n\n        # Access cache asynchronously\n        store = pod_informer.get_store()\n        all_pods = await store.async_list()  # Instant from cache\n\n        # Keep running to process events\n        await asyncio.sleep(3600)  # Run for 1 hour\n\n# Run the async monitor\nimport asyncio\nasyncio.run(monitor_pods())\n</code></pre>"},{"location":"#cache-configuration","title":"Cache Configuration","text":"<pre><code># Advanced caching with custom settings\nconfig = Config(\n    cache=Cache(\n        resync_period=600,  # 10 minutes\n        mode=\"strict\",      # Cache-only mode (no API fallback)\n        resources=[         # Cache specific resource types\n            k8s.apps.v1.Deployment,\n            k8s.core.v1.Service,\n        ],\n        max_items_per_resource=5000,  # Memory limit per resource type\n    )\n)\n\nwith config:\n    # All operations use cache - no unexpected API calls\n    deployment = k8s.apps.v1.Deployment.get(\"my-app\")  # From cache or None\n    services = k8s.core.v1.Service.list()  # From cache only\n\n    # Temporarily disable cache for fresh data\n    with config.cache.pause():\n        fresh_data = k8s.apps.v1.Deployment.get(\"my-app\")  # Direct API call\n\n    # Check cache status\n    informer = config.cache.get_informer(k8s.apps.v1.Deployment)\n    if informer.has_synced():\n        print(\"Cache is fully synchronized\")\n</code></pre>"},{"location":"#resource-filtering","title":"Resource Filtering","text":"<pre><code>from cloudcoil.client import Config\nfrom cloudcoil.caching import Cache\nimport cloudcoil.models.kubernetes as k8s\n\n# Cache only specific resource types for memory efficiency\nconfig = Config(\n    cache=Cache(\n        resources=[  # Only cache these types\n            k8s.apps.v1.Deployment,\n            k8s.core.v1.Service,\n            k8s.core.v1.ConfigMap,\n        ],\n        max_items_per_resource=1000  # Limit items per type\n    )\n)\n\nwith config:\n    # These use cache (instant)\n    deployment = k8s.apps.v1.Deployment.get(\"my-app\")\n    service = k8s.core.v1.Service.get(\"my-service\")\n\n    # This bypasses cache (not in resources list)\n    pod = k8s.core.v1.Pod.get(\"my-pod\")  # Direct API call\n</code></pre> <p>Performance Benefits: - Get operations: 100-200x faster (50ms \u2192 &lt;1ms) - List operations: 50-100x faster (100ms \u2192 &lt;5ms) - Real-time updates: Watch events keep cache fresh - Memory efficient: Configurable limits and automatic cleanup - Reduced API load: Shared informers minimize watch connections - Event-driven: React to changes in real-time without polling</p>"},{"location":"#testing-integration","title":"\ud83e\uddea Testing Integration","text":"<p>Cloudcoil provides powerful pytest fixtures for Kubernetes integration testing:</p>"},{"location":"#installation_1","title":"Installation","text":"<p>uv add cloudcoil[test]</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import pytest\nfrom cloudcoil.models.kubernetes import core, apps\n\n@pytest.mark.configure_test_cluster\ndef test_deployment(test_config):\n    with test_config:\n        # Creates a fresh k3d cluster for testing\n        deployment = apps.v1.Deployment.get(\"app\")\n        assert deployment.spec.replicas == 3\n</code></pre>"},{"location":"#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>@pytest.mark.configure_test_cluster(\n    cluster_name=\"my-test-cluster\",     # Custom cluster name\n    k3d_version=\"v5.7.5\",              # Specific k3d version\n    k8s_version=\"v1.31.4\",             # Specific K8s version\n    k8s_image=\"custom/k3s:latest\",     # Custom K3s image\n    remove=True                         # Auto-remove cluster after tests\n)\nasync def test_advanced(test_config):\n    with test_config:\n        # Async operations work too!\n        service = await core.v1.Service.async_get(\"kubernetes\")\n        assert service.spec.type == \"ClusterIP\"\n</code></pre>"},{"location":"#shared-clusters","title":"Shared Clusters","text":"<p>Reuse clusters across tests for better performance:</p> <pre><code>@pytest.mark.configure_test_cluster(\n    cluster_name=\"shared-cluster\",\n    remove=False  # Keep cluster after tests\n)\ndef test_first(test_config):\n    with test_config:\n        # Uses existing cluster if available\n        namespace = core.v1.Namespace.get(\"default\")\n        assert namespace.status.phase == \"Active\"\n\n@pytest.mark.configure_test_cluster(\n    cluster_name=\"shared-cluster\",  # Same cluster name\n    remove=True   # Last test removes the cluster\n)\ndef test_second(test_config):\n    with test_config:\n        # Uses same cluster as previous test\n        pods = core.v1.Pod.list(namespace=\"kube-system\")\n        assert len(pods) &gt; 0\n</code></pre>"},{"location":"#parallel-testing","title":"Parallel Testing","text":"<p>The fixtures are compatible with pytest-xdist for parallel testing:</p> <pre><code># Run tests in parallel\npytest -n auto tests/\n\n# Or specify number of workers\npytest -n 4 tests/\n</code></pre>"},{"location":"#testing-fixtures-api","title":"Testing Fixtures API","text":"<p>The testing module provides two main fixtures:</p> <ul> <li><code>test_cluster</code>: Creates and manages k3d clusters</li> <li>Returns path to kubeconfig file</li> <li>Handles cluster lifecycle</li> <li>Supports cluster reuse</li> <li> <p>Compatible with parallel testing</p> </li> <li> <p><code>test_config</code>: Provides configured <code>Config</code> instance</p> </li> <li>Uses test cluster kubeconfig</li> <li>Manages client connections</li> <li>Handles cleanup automatically</li> <li>Context manager support</li> </ul>"},{"location":"#mypy-integration","title":"\ud83d\udee1\ufe0f MyPy Integration","text":"<p>cloudcoil provides a mypy plugin that enables type checking for dynamically loaded kinds from the scheme. To enable the plugin, add this to your pyproject.toml:</p> <pre><code># pyproject.toml\n[tool.mypy]\nplugins = ['cloudcoil.mypy']\n</code></pre> <p>This plugin enables full type checking for scheme.get() calls when the kind name is a string literal:</p> <pre><code>from cloudcoil import resources\n\n# This will be correctly typed as k8s.batch.v1.Job\njob_class = resources.get_model(\"Job\")\n\n# Type checking works on the returned class\njob = job_class(\n    metadata={\"name\": \"test\"},  # type checked!\n    spec={\n        \"template\": {\n            \"spec\": {\n                \"containers\": [{\"name\": \"test\", \"image\": \"test\"}],\n                \"restartPolicy\": \"Never\"\n            }\n        }\n    }\n)\n</code></pre>"},{"location":"#model-generation","title":"\ud83c\udfd7\ufe0f Model Generation","text":"<p>Cloudcoil supports generating typed models from CustomResourceDefinitions (CRDs). You can either use the provided cookiecutter template or set up model generation manually.</p>"},{"location":"#using-the-cookiecutter-template","title":"Using the Cookiecutter Template","text":"<p>The fastest way to get started is using our cookiecutter template: cloudcoil-models-cookiecutter</p>"},{"location":"#codegen-config","title":"Codegen Config","text":"<p>Cloudcoil includes a CLI tool, cloudcoil-model-codegen, which reads configuration from your pyproject.toml under [tool.cloudcoil.codegen.models]. It supports options such as:</p> <p>\u2022 namespace: The Python package name for generated models \u2022 input: Path or URL to CRD (YAML/JSON) or OpenAPI schema \u2022 output: Output directory for the generated code \u2022 mode: Either \"resource\" (default) or \"base\" for the generated class hierarchy \u2022 crd-namespace: Inject a namespace for CRD resources \u2022 transformations / updates: Modify the schema before generation \u2022 exclude-unknown: Exclude definitions that cannot be mapped \u2022 aliases: Aliases for properties \u2022 additional-datamodel-codegen-args: Pass extra flags to the underlying generator  </p> <p>Example pyproject.toml config - </p> <pre><code>[[tool.cloudcoil.codegen.models]]\n# Unique name for the models\n# This will be used as the name for the setuptools entrypoints\nnamespace = \"cloudcoil.models.fluxcd\"\ninput = \"https://github.com/fluxcd/flux2/releases/download/v2.4.0/install.yaml\"\ncrd-namespace = \"io.fluxcd.toolkit\"\n</code></pre> <p>For more examples, check out the cloudcoil-models topic on Github.</p> <p>If you are building a models package to be used with cloudcoil, please make sure to tag it with this topic for discovery.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>For complete documentation, visit cloudcoil.github.io/cloudcoil</p>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>Apache License, Version 2.0 - see LICENSE</p>"},{"location":"#stargazers-over-time","title":"\ud83c\udf1f Stargazers over time","text":""},{"location":"api/","title":"API Reference","text":""}]}